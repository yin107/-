{"ast":null,"code":"import axios from \"axios\";\nconst codeMessage = {\n  200: \"服务器成功返回请求的数据\",\n  201: \"新建或修改数据成功\",\n  204: \"删除数据成功\",\n  400: \"发出的请求有错误，服务器没有进行新建或修改数据的操作\",\n  401: \"用户没有访问权限（令牌、用户名、密码错误）\"\n};\n//登录注册时候的axios封装\nexport function mylocalrequest(config) {\n  const instance = axios.create({\n    baseURL: \"http://127.0.0.1:300/pc\"\n  });\n  //响应拦截器\n  instance.interceptors.response.use(res => {\n    if (res.data.code === 200) {\n      console.log(res);\n      localStorage.setItem(\"refreshToken\", res.data.data.refreshToken);\n      this.notifySuccess(res.msg);\n    }\n    return res.data;\n  });\n  return instance(config);\n}\n//有权限接口\nexport function myrequest(config) {\n  const instance = axios.create({\n    baseURL: \"http://127.0.0.1:300/pc\"\n  });\n  const clearAuth = () => {\n    window.location.replace(\"/user/login\");\n    localStorage.clear();\n  };\n  instance.interceptors.request.use(config => {\n    let token = localStorage.getItem(\"token\");\n    if (token) {\n      config.headers[\"Authorization\"] = token;\n    }\n    return config;\n  });\n  instance.interceptors.response.use(res => {\n    //在2xx范围内的任何状态码都会触发此函数，主要用于处理响应数据\n    return res;\n  }, err => {\n    //任何超出2xx范围内的状态码都会触发此函数，主要用于处理响应错误\n    let {\n      status\n    } = err.response;\n    if (status === 401) {\n      //表示未授权\n      if (err.response.data.error === \"invalid token\") {\n        //token无效,值得是token的值不正确\n        clearAuth();\n      } else if (err.response.data.error == \"jwt expired\") {\n        //token过期\n        //发起刷新token的请求,此时请求头是之前获取到的refreshToken,在后端中，如果判断refreshToken验证成功的话，那么就刷新token并返回\n        axios.get(\"http://127.0.0.1:300/pc/user/refresh\", {\n          headers: {\n            Authorization: localStorage.getItem(\"refreshToken\")\n          }\n        }).then(() => {\n          clearAuth(); //这里后端的接口还不知道怎么写\n        });\n      }\n    }\n\n    return Promise.reject(err); //将未处理的异常往外抛\n  });\n\n  return instance(config);\n}\nexport function request(config) {\n  const instance = axios.create({\n    baseURL: \"/pc\"\n  });\n  instance.interceptors.response.use(res => {\n    if (Object.keys(codeMessage).includes(`${res.data.code}`)) {\n      this.notifySuccess(codeMessage[res.data.code]);\n    }\n    return res;\n  }, err => {\n    return err;\n  });\n  return instance(config);\n}","map":{"version":3,"names":["axios","codeMessage","mylocalrequest","config","instance","create","baseURL","interceptors","response","use","res","data","code","console","log","localStorage","setItem","refreshToken","notifySuccess","msg","myrequest","clearAuth","window","location","replace","clear","request","token","getItem","headers","err","status","error","get","Authorization","then","Promise","reject","Object","keys","includes"],"sources":["D:/前端/e家项目仿照/echome3_16/echome3_16/src/network/config.js"],"sourcesContent":["import axios from \"axios\";\r\nconst codeMessage = {\r\n  200: \"服务器成功返回请求的数据\",\r\n  201: \"新建或修改数据成功\",\r\n  204: \"删除数据成功\",\r\n  400: \"发出的请求有错误，服务器没有进行新建或修改数据的操作\",\r\n  401: \"用户没有访问权限（令牌、用户名、密码错误）\",\r\n};\r\n//登录注册时候的axios封装\r\nexport function mylocalrequest(config) {\r\n  const instance = axios.create({\r\n    baseURL: \"http://127.0.0.1:300/pc\",\r\n  });\r\n  //响应拦截器\r\n  instance.interceptors.response.use((res) => {\r\n    if (res.data.code === 200) {\r\n      console.log(res);\r\n      localStorage.setItem(\"refreshToken\", res.data.data.refreshToken);\r\n      this.notifySuccess(res.msg);\r\n    }\r\n    return res.data;\r\n  });\r\n  return instance(config);\r\n}\r\n//有权限接口\r\nexport function myrequest(config) {\r\n  const instance = axios.create({\r\n    baseURL: \"http://127.0.0.1:300/pc\",\r\n  });\r\n\r\n  const clearAuth = () => {\r\n    window.location.replace(\"/user/login\");\r\n    localStorage.clear();\r\n  };\r\n  instance.interceptors.request.use((config) => {\r\n    let token = localStorage.getItem(\"token\");\r\n    if (token) {\r\n      config.headers[\"Authorization\"] = token;\r\n    }\r\n    return config;\r\n  });\r\n  instance.interceptors.response.use(\r\n    (res) => {\r\n      //在2xx范围内的任何状态码都会触发此函数，主要用于处理响应数据\r\n      return res;\r\n    },\r\n    (err) => {\r\n      //任何超出2xx范围内的状态码都会触发此函数，主要用于处理响应错误\r\n      let { status } = err.response;\r\n      if (status === 401) {\r\n        //表示未授权\r\n        if (err.response.data.error === \"invalid token\") {\r\n          //token无效,值得是token的值不正确\r\n          clearAuth();\r\n        } else if (err.response.data.error == \"jwt expired\") {\r\n          //token过期\r\n         //发起刷新token的请求,此时请求头是之前获取到的refreshToken,在后端中，如果判断refreshToken验证成功的话，那么就刷新token并返回\r\n          axios\r\n            .get(\"http://127.0.0.1:300/pc/user/refresh\", {\r\n              headers: { Authorization: localStorage.getItem(\"refreshToken\") },\r\n            })\r\n            .then(() => {\r\n\t\t\t\tclearAuth();//这里后端的接口还不知道怎么写\r\n            });\r\n        }\r\n      }\r\n\r\n      return Promise.reject(err); //将未处理的异常往外抛\r\n    }\r\n  );\r\n  return instance(config);\r\n}\r\n\r\nexport function request(config) {\r\n  const instance = axios.create({\r\n    baseURL: \"/pc\",\r\n  });\r\n\r\n  instance.interceptors.response.use(\r\n    (res) => {\r\n      if (Object.keys(codeMessage).includes(`${res.data.code}`)) {\r\n        this.notifySuccess(codeMessage[res.data.code]);\r\n      }\r\n      return res;\r\n    },\r\n    (err) => {\r\n      return err;\r\n    }\r\n  );\r\n  return instance(config);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}